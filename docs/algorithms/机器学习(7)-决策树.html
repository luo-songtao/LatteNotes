<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>机器学习(七)-决策树</title>
  <link rel="stylesheet" href="/css/main.css">

  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>机器学习(七)-决策树 | MicroNotes</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="机器学习(七)-决策树" />
<meta name="author" content="LuoSongtao" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="介绍" />
<meta property="og:description" content="介绍" />
<link rel="canonical" href="http://0.0.0.0:4000/algorithms/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(7)-%E5%86%B3%E7%AD%96%E6%A0%91" />
<meta property="og:url" content="http://0.0.0.0:4000/algorithms/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(7)-%E5%86%B3%E7%AD%96%E6%A0%91" />
<meta property="og:site_name" content="MicroNotes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-30T19:00:07-05:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"LuoSongtao"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/algorithms/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(7)-%E5%86%B3%E7%AD%96%E6%A0%91"},"description":"介绍","@type":"BlogPosting","headline":"机器学习(七)-决策树","dateModified":"2020-03-30T19:00:07-05:00","url":"http://0.0.0.0:4000/algorithms/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(7)-%E5%86%B3%E7%AD%96%E6%A0%91","datePublished":"2020-03-30T19:00:07-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

</head>

<body>
  <div id="wrapper">
    <header>
  
  
  <div class="container">
      

      <div style="padding-left: 42px;">
        <a id="username" href="/">
        
        <span style="font-size: x-large; color: #6a9fb5;"># </span>
        <span style="font-size: x-large; color: #aa759f;">luosongtao</span>
        <span style="font-size: x-large; color: #6a9fb5;">@</span>
        <span style="font-size: x-large; color: #83a;">home:</span>
        <span style="font-size: x-large; color: #cc0000;">~$</span>
        </a>
        
<div id="search">
	<input type="text" id="search-input" placeholder=" find / -name " style="vertical-align:middle;">
	<ul id="results-container"></ul>
</div>

<!-- script pointing to jekyll-search.js -->
<script src="/assets/js/simple-jekyll-search.min.js"></script>
<script async src="/searchdata.js"></script>


      </div>

      <ul id="results-container"></ul>

      <nav class="nav">
    
    
        
        <h3><a href="/">最新</a></h3>
        
    
        
        <h3><a href="/algorithms">Algorithms</a></h3>
        
    
        
        <h3><a href="/optimization">Optimization</a></h3>
        
    
        
        <h3><a href="/algebra">代数论</a></h3>
        
    
        
        <h3><a href="/docker">Docker</a></h3>
        
    
        
        <h3><a href="/bigdata">大数据</a></h3>
        
    
        
        <h3><a href="/mathematical-analysis">数学分析</a></h3>
        
    
        
        <h3><a href="/probability-theory">概率论</a></h3>
        
    
        
        <h3><a href="/others">其他</a></h3>
        
    
</nav>
      <div class="header-links">
        
        <a href="/archive"><h2 class="header-link">时间轴</h2></a>
<a href="/about"><h2 class="header-link">关于</h2></a>
<!--<a href="/atom.xml"><h2 class="header-link">RSS</h2></a>-->
      </div>
  <div>

</header>
    
    <div class="container">
      <article>
  <h1>机器学习(七)-决策树</h1>
  <time datetime="2020-03-30T19:00:07-05:00" class="by-line">30 Mar 2020</time>
  <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#介绍">介绍</a>
<ul>
<li class="toc-entry toc-h4"><a href="#决策树与if-then规则">决策树与if-then规则</a></li>
<li class="toc-entry toc-h4"><a href="#决策树与条件概率分布">决策树与条件概率分布</a></li>
<li class="toc-entry toc-h4"><a href="#决策树的学习">决策树的学习</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#特征选择">特征选择</a>
<ul>
<li class="toc-entry toc-h4"><a href="#信息增益information-gain">信息增益(Information Gain)</a></li>
<li class="toc-entry toc-h4"><a href="#信息增益率">信息增益率</a></li>
<li class="toc-entry toc-h4"><a href="#基尼指数gini-index">基尼指数(Gini Index)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#决策树的生成">决策树的生成</a>
<ul>
<li class="toc-entry toc-h4"><a href="#id3算法">ID3算法</a></li>
<li class="toc-entry toc-h4"><a href="#c45算法">C4.5算法</a></li>
<li class="toc-entry toc-h4"><a href="#cart算法">CART算法</a>
<ul>
<li class="toc-entry toc-h5"><a href="#分类树">分类树</a></li>
<li class="toc-entry toc-h5"><a href="#回归树">回归树</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#决策树的剪枝">决策树的剪枝</a>
<ul>
<li class="toc-entry toc-h4"><a href="#预剪枝">预剪枝</a></li>
<li class="toc-entry toc-h4"><a href="#后剪枝">后剪枝</a></li>
</ul>
</li>
</ul><h2 id="介绍">
<a class="anchor" href="#%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span class="octicon octicon-link"></span></a>介绍</h2>

<ul>
  <li>决策树是一种基本的分类与回归方法。决策树呈树形结构。决策树是一种判别模型，天然支持多分类问题
    <ul>
      <li>分类树的映射函数是多维空间的分段线性划分，即用平行于各坐标轴的超平面对空间进行切分</li>
      <li>回归树的映射函数是分段常数函数</li>
    </ul>
  </li>
  <li>决策树是分段线性函数而不是线性函数，它具有非线性建模能力。理论上，只要划分得足够细，分段常熟函数可以逼近闭区间熵任意函数到任意指定精度。</li>
</ul>

<h4 id="决策树与if-then规则">
<a class="anchor" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8Eif-then%E8%A7%84%E5%88%99" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策树与if-then规则</h4>

<ul>
  <li>决策树到if-then规则：
    <ul>
      <li>由决策树的根节点到叶节点的每一条路径构建一条规则</li>
      <li>路径上的特征对应着规则的条件，而叶节点的类对应着规则的结论</li>
    </ul>
  </li>
  <li>决策树的路径(if-then规则集合)性质：互斥并且完备
    <ul>
      <li>每一个实例都能且只能被一条路径或一条规则所覆盖</li>
    </ul>
  </li>
</ul>

<h4 id="决策树与条件概率分布">
<a class="anchor" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策树与条件概率分布</h4>

<ul>
  <li>决策树表示给定条件下类的条件概率分布。其定义在特征空间的一个划分上
    <ul>
      <li>将特征空间划分为互不相交的单元或区域，在每个单元定义一个类的概率分布就构成了一个条件概率分布</li>
      <li>决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成</li>
      <li>各叶节点(单元)上条件概率往往偏向某一个类</li>
    </ul>
  </li>
</ul>

<h4 id="决策树的学习">
<a class="anchor" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策树的学习</h4>

<ul>
  <li>决策树学习本质上是从训练数据集中归纳出一组分类规则。
    <ul>
      <li>能训练出的与数据集不相矛盾的决策树可能有多个。因此最终需要的是一个与训练数据矛盾最小的决策树，同时具有很好的泛化能力</li>
    </ul>
  </li>
  <li>或者说决策树学习是由训练数据集估计条件概率模型
    <ul>
      <li>基于特征空间划分的类的条件概率模型有无穷多个，最终得到的模型不仅对训练数据有很好的拟合，还需要对未知数据有很好的预测</li>
    </ul>
  </li>
  <li>决策树学习过程：
    <ul>
      <li>特征选择
        <ul>
          <li>决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得各个子数据集有一个最好的分类的过程</li>
        </ul>
      </li>
      <li>决策树生成</li>
      <li>决策树修剪(剪枝)</li>
    </ul>
  </li>
</ul>

<h2 id="特征选择">
<a class="anchor" href="#%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>特征选择</h2>

<ul>
  <li>特征选择：决定用哪个特征来划分特征空间
    <ul>
      <li>选取对训练数据具有分类能力的特征</li>
      <li>如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称该特征没有分类能力</li>
      <li>划分时，希望决策树的分支节点所包含的样本尽可能属于同一类别，即结点的”纯度”越来越高</li>
    </ul>
  </li>
</ul>

<h4 id="信息增益information-gain">
<a class="anchor" href="#%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8Ainformation-gain" aria-hidden="true"><span class="octicon octicon-link"></span></a>信息增益(Information Gain)</h4>

<ul>
  <li>
    <p>设$X$是一个去有限个值的离散随机变量，其概率分布为：</p>

    <script type="math/tex; mode=display">P(X=x_i) = p_i, \qquad i=1,2,...,n</script>
  </li>
  <li>
    <p>熵$H(X)$(表示随机变量不确定性的度量)：</p>

    <script type="math/tex; mode=display">H(X) = - \sum_{i=1}^n p_i\log p_i \qquad n表示X可能的取值个数</script>

    <ul>
      <li>熵的单位：
        <ul>
          <li>bit: 当对数以2为底</li>
          <li>nat: 当对数以自然对数为底</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>信息熵(熵本是物理中的概念，但由香农引入到信息论中后，熵也被称为信息熵)
    <ul>
      <li>对于一个训练样本集合$D$而言，信息熵是度量样本集合纯度的一种常用指标</li>
      <li>
        <p>假定当前样本集合$D$中第$i$类样本(共有$k$个类别)所占的比例为$p_i$，则$D$的信息熵为：</p>

        <script type="math/tex; mode=display">H(D) = - \sum_{i=1}^k p_i\log p_i \qquad k表示样本集合中类别总数</script>
      </li>
      <li>信息熵越小，表示$D$的纯度越高</li>
    </ul>
  </li>
  <li>
    <p>条件熵$H(Y\vert X)$(表示已知随机变量$X$的条件下随机变量$Y$的不确定性)：</p>

    <script type="math/tex; mode=display">% <![CDATA[
\begin{aligned} H(P) &= H(Y \vert X) \\ &=  \sum_{i=1}^n P(X=x_i) H(Y \vert X=x_i) \\ &= - \sum_{i=1}^n P(X=x_i) \cdot \sum_{j=1}^k P(Y=y_j \vert X=x_i) \log P(Y=y_j \vert X=x_i) \qquad n、k分别表示X、Y的取值个数 \\ &= -\sum_{x,y} P(Y=y, X=x) \log P(Y=y \vert X=x) \end{aligned} %]]></script>
  </li>
  <li>信息增益表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度
    <ul>
      <li>
        <p>假设特征$X$有$n$个可能的取值$(x_1, x_2,…,x_n)$，训练数据集$D$中共有$k$类样本$(y_1,y_2,…,y_k)$，则特征$X$对数据集$D$进行划分所获得的信息增益$gain(D,X)$为：</p>

        <script type="math/tex; mode=display">% <![CDATA[
\begin{aligned} gain(D,X) &= H(D) - H(D\vert X) \\ &= - \sum_{j=1}^k \tilde{P}(Y=y_j)\log \tilde{P}(Y=y_j) + \sum_{i=1}^n \tilde{P}(X=x_i) \cdot \sum_{j=1}^k \tilde{P}(Y=y_j \vert X=x_i) \log \tilde{P}(Y=y_j \vert X=x_i) \end{aligned} %]]></script>
      </li>
      <li>
        <p>式中$\tilde{P}$表示根据频数计算而得的概率(经验分布)</p>
      </li>
    </ul>
  </li>
  <li>利用信息增益准则的特征选择方法是：对训练数据集$D$，计算其每个特征的信息增益，选择信息增益最大的特征</li>
</ul>

<h4 id="信息增益率">
<a class="anchor" href="#%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E7%8E%87" aria-hidden="true"><span class="octicon octicon-link"></span></a>信息增益率</h4>

<ul>
  <li>
    <p>以最大信息增益进行选取的特征，倾向于选择特征可取值数较多的特征，如果需要消除这样的影响，那么可以使用最大信息增益率准则来进行选取</p>
  </li>
  <li>
    <p>信息增益率$gain_{ratio}(D,X)$:</p>

    <script type="math/tex; mode=display">gain_{ratio}(D,X) = \frac {gain(D,X)}{H_X(D)}</script>

    <ul>
      <li>
        <p>$H_X(D)$表示数据集$D$关于特征$X$的取值的熵(经验熵)</p>

        <script type="math/tex; mode=display">H_X(D) = -\sum_{i=1}^n \tilde{P}(X=x_i) \log \tilde{P}(X=x_i) \qquad n表示特征X的可能取值个数</script>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>但要注意，信息增益率准则虽然减少了对特征可取值数较多的特征的影响，但同时它对特征可取值数较少的属性会有所偏好</strong></p>
    <ul>
      <li>一种比较折中的方案是：<strong>先从候选划分特征中找出信息增益高于平均水平的特征，再从中选择信息增益率最高的特征</strong>
</li>
    </ul>
  </li>
</ul>

<h4 id="基尼指数gini-index">
<a class="anchor" href="#%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%95%B0gini-index" aria-hidden="true"><span class="octicon octicon-link"></span></a>基尼指数(Gini Index)</h4>

<ul>
  <li>
    <p>数据集$D$的纯度也可以用<strong>基尼值</strong>来度量：</p>

    <script type="math/tex; mode=display">% <![CDATA[
\begin{aligned} Gini(D) &= \sum_{i=1}^k \sum_{i' \neq i} P(Y=y_i)P(Y=y_{i'}) \\ &= 1- \sum_{i=1}^k P(Y=y_i)^2 \end{aligned} %]]></script>

    <ul>
      <li>基尼值反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率</li>
      <li>基尼值越小，数据集的纯度越高</li>
    </ul>
  </li>
  <li>
    <p>特征$X$的<strong>基尼指数</strong>：</p>

    <script type="math/tex; mode=display">Gini\_Index(D,X) = \sum_{i=1}^n \tilde{P}(X=x_i) \cdot Gini(D_X)</script>

    <ul>
      <li>其中<script type="math/tex">D_X = \{(x_i, y_i) \in D \vert X = x_i \}</script>
</li>
      <li>基尼指数指经$X=x_i$分割后集合$D$的纯度</li>
    </ul>
  </li>
</ul>

<h2 id="决策树的生成">
<a class="anchor" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策树的生成</h2>

<h4 id="id3算法">
<a class="anchor" href="#id3%E7%AE%97%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>ID3算法</h4>

<ul>
  <li>ID3算法是在决策树各节点上应用信息增益准则选择特征，递归地构建决策树
    <ul>
      <li>从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点</li>
      <li>在对子节点递归地用以上方法，构建决策树</li>
      <li>直到所有特征的信息增益均很小或没有特征可以选择为止</li>
    </ul>
  </li>
  <li>ID3算法相当于用极大似然法进行概率选择</li>
  <li>注意：ID3算法只有树的生成，所以该算法生成的树容易产生过拟合</li>
</ul>

<h4 id="c45算法">
<a class="anchor" href="#c45%E7%AE%97%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>C4.5算法</h4>

<ul>
  <li>C4.5算法与ID3算法相似，但主要是使用信息增益率来选择特征</li>
</ul>

<h4 id="cart算法">
<a class="anchor" href="#cart%E7%AE%97%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>CART算法</h4>

<ul>
  <li>
    <p>分类与回归树(CART)，分为分类树和回归树，分别用于分类问题和回归问题</p>
  </li>
  <li>
    <p>分类与回归树是一颗二叉决策树</p>
  </li>
  <li>
    <p>分类与回归树生成需要，第一，考虑使用特征向量的哪个分量进行判定；第二，确定分裂分量后，如何划分训练样本，让一部分进入左子树，一部分进入右子树</p>
    <ul>
      <li>连续数值型变量：寻找一个分裂阈值
        <ul>
          <li>均方误差</li>
        </ul>
      </li>
      <li>离散型类别变量：确定一个子集划分
        <ul>
          <li>基尼指数</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="分类树">
<a class="anchor" href="#%E5%88%86%E7%B1%BB%E6%A0%91" aria-hidden="true"><span class="octicon octicon-link"></span></a>分类树</h5>

<ul>
  <li>
    <p>分类树使用基尼指数，其目标是把数据分成两部分后，两个子集都尽可能的纯，也就是左右子树集合的基尼指数和最小的，即：</p>

    <script type="math/tex; mode=display">\min \frac {count(D_l)}{count(D)}Gini(D_l) + \frac {count(D_r)}{count(D)}Gini(D_r)</script>
  </li>
</ul>

<h5 id="回归树">
<a class="anchor" href="#%E5%9B%9E%E5%BD%92%E6%A0%91" aria-hidden="true"><span class="octicon octicon-link"></span></a>回归树</h5>

<ul>
  <li>
    <p>回归树使用样本均方误差作为评判标准，其目标是把数据分成两部分后，两个子集的均方误差和最小，即</p>

    <script type="math/tex; mode=display">\min \frac {count(D_l)}{count(D)}E(D_l) + \frac {count(D_r)}{count(D)}E(D_r)</script>

    <script type="math/tex; mode=display">E(D) = \frac {1}{count(D)} \sum_{i=1}^{count(D)} (x_i - \overline{x})</script>
  </li>
</ul>

<h2 id="决策树的剪枝">
<a class="anchor" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E5%89%AA%E6%9E%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>决策树的剪枝</h2>

<ul>
  <li>为了调整决策树的过拟合问题，需要对决策树进行剪枝处理
    <ul>
      <li>预剪枝</li>
      <li>后剪枝</li>
    </ul>
  </li>
</ul>

<h4 id="预剪枝">
<a class="anchor" href="#%E9%A2%84%E5%89%AA%E6%9E%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>预剪枝</h4>

<ul>
  <li>在决策树生成过程中，对分别前和分裂后的就决策树整体损失(代价)进行计算，如果分裂后的损失更大，那么就停止分裂，反之才继续分裂</li>
</ul>

<h4 id="后剪枝">
<a class="anchor" href="#%E5%90%8E%E5%89%AA%E6%9E%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>后剪枝</h4>

<ul>
  <li>
    <p>在决策树完全生成后，使用自下而上的顺序考虑逐个剪掉内部节点，同时在剪枝前后，分别对决策树进行整体损失计算，如果剪枝后损失更小，那么就执行剪枝，否则，不执行</p>
  </li>
  <li>
    <p>注意，在CART中，后剪枝是使用自下而上的方式剪枝，并生成一个子树序列，利用交叉验证方式，测试子树序列的各颗子树的均方误差或基尼指数，选取相应值最小的决策树子树评为最优的决策树</p>
  </li>
</ul>

</article>
      <section id="main_content">
        <ul>
            
        </ul>
      </section>
    </div>
  </div>
   <footer>
  <a href="/">
    <span>
        <b>LuoSongtao</b>
    </span>
    
    <span>© 2020</span>
  </a>
</footer>

  
</body>

</html>